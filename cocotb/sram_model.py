"""Python behavioral model for gf180mcu_ic_1x1_sram_u8b24k

Generated by sram-forge
24KB SRAM (8-bit x 24K) for 1x1 wafer.space slot
This model provides a reference implementation for verification.
It models the expected behavior of the SRAM array.
"""


class SramModel:
    """Behavioral model of the SRAM array.

    Configuration:
        Total Words: 24576
        Data Width: 8 bits
        Address Bits: 15
        SRAM Count: 48
    """

    def __init__(self, size: int = 24576, width: int = 8):
        """Initialize the SRAM model.

        Args:
            size: Number of addressable words.
            width: Bits per word.
        """
        self.size = size
        self.width = width
        self.mask = (1 << width) - 1  # Data mask (0xFF for 8-bit)

        # Initialize memory to zero
        self.memory = [0] * size

    def write(self, addr: int, data: int, wem: int = 0) -> None:
        """Write data to memory.

        Args:
            addr: Address to write to.
            data: Data to write.
            wem: Write enable mask (active low). 0 = write bit, 1 = preserve bit.
        """
        if addr >= self.size:
            raise ValueError(f"Address 0x{addr:X} out of range (max 0x{self.size - 1:X})")

        data = data & self.mask


        self.memory[addr] = data

    def read(self, addr: int) -> int:
        """Read data from memory.

        Args:
            addr: Address to read from.

        Returns:
            Data at the address.
        """
        if addr >= self.size:
            raise ValueError(f"Address 0x{addr:X} out of range (max 0x{self.size - 1:X})")

        return self.memory[addr]

    def dump(self, start: int = 0, count: int = 16) -> str:
        """Dump memory contents for debugging.

        Args:
            start: Starting address.
            count: Number of words to dump.

        Returns:
            Formatted memory dump string.
        """
        lines = []
        for i in range(count):
            addr = start + i
            if addr >= self.size:
                break
            data = self.memory[addr]
            lines.append(f"0x{addr:04X}: 0x{data:02X}")
        return "\n".join(lines)

    def clear(self) -> None:
        """Clear all memory to zero."""
        self.memory = [0] * self.size

    def fill(self, pattern: int) -> None:
        """Fill all memory with a pattern.

        Args:
            pattern: Pattern to fill with.
        """
        pattern = pattern & self.mask
        self.memory = [pattern] * self.size


# Standalone test
if __name__ == "__main__":
    model = SramModel()
    print(f"SRAM Model: {model.size} words x {model.width} bits")

    # Test basic operations
    model.write(0, 0xAA)
    model.write(1, 0x55)
    last_addr = 24575
    model.write(last_addr, 0xFF)

    print("\nMemory dump:")
    print(model.dump(0, 4))

    print(f"\nRead from 0x0000: 0x{model.read(0):02X}")
    print(f"Read from 0x0001: 0x{model.read(1):02X}")
    print(f"Read from 0x{last_addr:04X}: 0x{model.read(last_addr):02X}")