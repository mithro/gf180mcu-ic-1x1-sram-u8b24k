"""cocotb testbench for gf180mcu_ic_1x1_sram_u8b24k

Generated by sram-forge
24KB SRAM (8-bit x 24K) for 1x1 wafer.space slot
Configuration:
  Total SRAMs: 48
  Total Words: 24576
  Address Bits: 15
  Data Width: 8
"""

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge, FallingEdge, Timer
from cocotb.result import TestFailure

from sram_model import SramModel


async def reset_dut(dut):
    """Reset the DUT."""
    dut.rst_n.value = 0
    dut.ce_n.value = 1
    dut.we_n.value = 1
    dut.addr.value = 0
    dut.din.value = 0
    await Timer(100, units="ns")
    dut.rst_n.value = 1
    await Timer(100, units="ns")


async def write_word(dut, addr, data):
    """Write a word to the SRAM."""
    dut.addr.value = addr
    dut.din.value = data
    dut.ce_n.value = 0
    dut.we_n.value = 0
    await RisingEdge(dut.clk)
    dut.ce_n.value = 1
    dut.we_n.value = 1
    await RisingEdge(dut.clk)


async def read_word(dut, addr):
    """Read a word from the SRAM."""
    dut.addr.value = addr
    dut.ce_n.value = 0
    dut.we_n.value = 1  # Read mode
    await RisingEdge(dut.clk)
    await RisingEdge(dut.clk)  # Wait for output
    data = int(dut.dout.value)
    dut.ce_n.value = 1
    return data


@cocotb.test()
async def test_write_read_basic(dut):
    """Test basic write and read operations."""
    clock = Clock(dut.clk, 40, units="ns")  # 25 MHz
    cocotb.start_soon(clock.start())

    model = SramModel(24576, 8)
    await reset_dut(dut)

    # Test a few addresses
    test_data = [
        (0, 0xAA),
        (1, 0x55),
        (24575, 0xFF),
        (12288, 0x12),
    ]

    # Write phase
    for addr, data in test_data:
        await write_word(dut, addr, data)
        model.write(addr, data)
        dut._log.info(f"Wrote 0x{data:02X} to address 0x{addr:04X}")

    # Read phase
    for addr, expected in test_data:
        actual = await read_word(dut, addr)
        model_data = model.read(addr)
        dut._log.info(f"Read 0x{actual:02X} from address 0x{addr:04X} (expected 0x{expected:02X})")
        assert actual == expected, f"Mismatch at 0x{addr:04X}: got 0x{actual:02X}, expected 0x{expected:02X}"
        assert actual == model_data, f"Model mismatch at 0x{addr:04X}"


@cocotb.test()
async def test_write_read_all_srams(dut):
    """Test write/read to each SRAM block."""
    clock = Clock(dut.clk, 40, units="ns")
    cocotb.start_soon(clock.start())

    model = SramModel(24576, 8)
    await reset_dut(dut)

    # Write to first address of each SRAM block
    sram_size = 512
    for i in range(48):
        addr = i * sram_size
        data = (i + 1) & 0xFF
        await write_word(dut, addr, data)
        model.write(addr, data)
        dut._log.info(f"SRAM {i}: Wrote 0x{data:02X} to address 0x{addr:04X}")

    # Read back from each SRAM
    for i in range(48):
        addr = i * sram_size
        expected = (i + 1) & 0xFF
        actual = await read_word(dut, addr)
        dut._log.info(f"SRAM {i}: Read 0x{actual:02X} from address 0x{addr:04X}")
        assert actual == expected, f"SRAM {i} mismatch: got 0x{actual:02X}, expected 0x{expected:02X}"


@cocotb.test()
async def test_address_boundary(dut):
    """Test address decoding at SRAM boundaries."""
    clock = Clock(dut.clk, 40, units="ns")
    cocotb.start_soon(clock.start())

    model = SramModel(24576, 8)
    await reset_dut(dut)

    sram_size = 512

    # Test boundary addresses
    boundary_tests = [
        (sram_size - 1, 0xAA),      # Last address of SRAM 0
        (sram_size, 0x55),          # First address of SRAM 1
        (sram_size * 2 - 1, 0xBB),  # Last address of SRAM 1
        (sram_size * 2, 0xCC),      # First address of SRAM 2
    ]

    # Write phase
    for addr, data in boundary_tests:
        if addr < 24576:
            await write_word(dut, addr, data)
            model.write(addr, data)
            dut._log.info(f"Boundary write: 0x{data:02X} to 0x{addr:04X}")

    # Read phase
    for addr, expected in boundary_tests:
        if addr < 24576:
            actual = await read_word(dut, addr)
            dut._log.info(f"Boundary read: 0x{actual:02X} from 0x{addr:04X} (expected 0x{expected:02X})")
            assert actual == expected, f"Boundary mismatch at 0x{addr:04X}"


@cocotb.test()
async def test_sequential_write_read(dut):
    """Test sequential write followed by read."""
    clock = Clock(dut.clk, 40, units="ns")
    cocotb.start_soon(clock.start())

    model = SramModel(24576, 8)
    await reset_dut(dut)

    # Write 256 sequential addresses
    for addr in range(min(256, 24576)):
        data = addr & 0xFF
        await write_word(dut, addr, data)
        model.write(addr, data)

    # Read back and verify
    errors = 0
    for addr in range(min(256, 24576)):
        expected = addr & 0xFF
        actual = await read_word(dut, addr)
        if actual != expected:
            dut._log.error(f"Sequential mismatch at 0x{addr:04X}: got 0x{actual:02X}, expected 0x{expected:02X}")
            errors += 1

    assert errors == 0, f"Sequential test had {errors} errors"
    dut._log.info("Sequential write/read test passed")


